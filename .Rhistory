names(regr) <- c("SA", "VA", "CB", "barWA", "barWB", "bara", "VB")
############################################
# prepare data for counterfactuals
# cmle
xThi <- xTlo <- thetaCMLE
xThi[19] <- 0
xTlo[19] <- -6
xThi[20] <- 0
xTlo[20] <- 0
Uhi.cmle <- vec2U.regr(xThi, regr)
Ulo.cmle <- vec2U.regr(xTlo, regr)
U.cmle <- vec2U.regr(thetaCMLE, regr)
Uhi.cmle$sig <- Ulo.cmle$sig <- U.cmle$sig <- rep(1,M)
# tmle
xThi <- xTlo <- thetaMLE
xThi[19] <- 0
xTlo[19] <- -6
xThi[20] <- 0
xTlo[20] <- 0
Uhi.tmle <- vec2U.regr(xThi, regr)
Ulo.tmle <- vec2U.regr(xTlo, regr)
U.tmle <- vec2U.regr(thetaMLE, regr)
Uhi.tmle$sig <- Ulo.tmle$sig <- U.tmle$sig <- rep(1,M)
info <- data.frame(gameID=X$gameID,
sender = cow[as.character(X$ccode1),]$stateabb,
receiver = cow[as.character(X$ccode2),]$stateabb,
year = X$tenyear)
############################################
# counterfactuals
use <- 93
es <- function(x,k){return(x[k])}
nstep <- 30
X$gameID
############################################
############################################
######## Estimating Signaling Games ########
########     Economic Sanctions     ########
########        Comp Stat           ########
############################################
############################################
rm(list=ls())
library(pbivnorm)
library(Formula)
library(foreign)
library(ggplot2)
library(doRNG)
library(rootSolve)
library(doParallel)
############################################
# Functions
source("signalingFunctions_main.r")
source("gradientFunctions.r")
############################################
# Data
load("SanctionsDataSet.rdata")
# cow <- read.csv("states2011.csv")
# cow <- unique(cow[,1:3])
# rownames(cow) <- cow$ccode
# Find and remove missing values
missing <- apply(is.na(Xall), 1, max)
Y <- Yall[,missing==0]
X <- Xall[missing==0,]
M <- dim(Y)[2]
rm(Yall, Xall, missing)
############################################
# CMLE
load("CMLE_estimation_output.rdata")
out.cmle <- c(output)
eqCMLE <- plogis(out.cmle[(length(out.cmle)-M+1):length(out.cmle)])
thetaCMLE <- out.cmle[1:(length(out.cmle)-M)]
rm(value, out.cmle, output)
############################################
# tMLE
load("estimation_output.Rdata")
thetaMLE <- tML.out$model$estimate
rm(tML.out)
############################################
# prepare data for counterfactuals
# create regression matrices
f1 <- as.Formula(~ sqrt(senderecondep) + senderdemocracy + contig + ally -1|#SA
anticipatedsendercosts|#VA
sqrt(targetecondep) + anticipatedtargetcosts + contig + ally|#CB
sqrt(senderecondep) + senderdemocracy + lncaprat | #barWA
targetdemocracy + lncaprat| #barWB
senderdemocracy| #bara
-1) #VB
Xhi <- Xlo <- X
regrhi <- list()
regrlo <- list()
regr <- list()
for(i in 1:7){
regrhi[[i]] <- model.matrix(f1, data=Xhi, rhs=i)
regrlo[[i]] <- model.matrix(f1, data=Xlo, rhs=i)
regr[[i]] <- model.matrix(f1, data=X, rhs=i)
}
names(regrhi) <- c("SA", "VA", "CB", "barWA", "barWB", "bara", "VB")
names(regrlo) <- c("SA", "VA", "CB", "barWA", "barWB", "bara", "VB")
names(regr) <- c("SA", "VA", "CB", "barWA", "barWB", "bara", "VB")
############################################
# prepare data for counterfactuals
# cmle
xThi <- xTlo <- thetaCMLE
xThi[19] <- 0
xTlo[19] <- -6
xThi[20] <- 0
xTlo[20] <- 0
Uhi.cmle <- vec2U.regr(xThi, regr)
Ulo.cmle <- vec2U.regr(xTlo, regr)
U.cmle <- vec2U.regr(thetaCMLE, regr)
Uhi.cmle$sig <- Ulo.cmle$sig <- U.cmle$sig <- rep(1,M)
# tmle
xThi <- xTlo <- thetaMLE
xThi[19] <- 0
xTlo[19] <- -6
xThi[20] <- 0
xTlo[20] <- 0
Uhi.tmle <- vec2U.regr(xThi, regr)
Ulo.tmle <- vec2U.regr(xTlo, regr)
U.tmle <- vec2U.regr(thetaMLE, regr)
Uhi.tmle$sig <- Ulo.tmle$sig <- U.tmle$sig <- rep(1,M)
info <- data.frame(gameID=X$gameID[93],
sender = "USA",
receiver = "CHN",
year = X$tenyear)
X$tenyear
info <- data.frame(gameID=X$gameID[93],
sender = "USA",
receiver = "CHN",
year = X$tenyear[93])
info
############################################
# counterfactuals
use <- 93
es <- function(x,k){return(x[k])}
nstep <- 30
Ulo.cmle
out.cmle <- signalEQC(lapply(Ulo.cmle,es,k=use), lapply(Uhi.cmle,es,k=use), length.out=nstep,gridsize=1e4,comp=T)
out.tmle <- signalEQC(lapply(Ulo.tmle,es,k=use), lapply(Uhi.tmle,es,k=use), length.out=nstep,gridsize=1e4,comp=T)
ggdata <- data.frame(x = c(out.cmle[,"i"], out.tmle[,"i"]),
eq = c(out.cmle[,"sols"], out.tmle[,"sols"]),
pc = c(out.cmle[,"sols.pc"], out.tmle[,"sols.pc"]),
pars = c(rep("CMLE", dim(out.cmle)[1]), rep("tMLE", dim(out.tmle)[1])))
vldata <- data.frame(vl = (nstep/6)*c(thetaCMLE[19] + thetaCMLE[20]*X$senderdemocracy[use],
thetaMLE[19] + thetaMLE[20]*X$senderdemocracy[use]) + nstep,
pars = c("CMLE", "tMLE"))
############################################
############################################
######## Estimating Signaling Games ########
########     Economic Sanctions     ########
########        Comp Stat           ########
############################################
############################################
rm(list=ls())
library(pbivnorm)
library(Formula)
library(foreign)
library(ggplot2)
library(doRNG)
library(rootSolve)
library(doParallel)
############################################
# Functions
source("signalingFunctions_main.r")
source("gradientFunctions.r")
############################################
# Data
load("SanctionsDataSet.rdata")
# cow <- read.csv("states2011.csv")
# cow <- unique(cow[,1:3])
# rownames(cow) <- cow$ccode
# Find and remove missing values
missing <- apply(is.na(Xall), 1, max)
Y <- Yall[,missing==0]
X <- Xall[missing==0,]
M <- dim(Y)[2]
rm(Yall, Xall, missing)
############################################
# CMLE
load("CMLE_estimation_output.rdata")
out.cmle <- c(output)
eqCMLE <- plogis(out.cmle[(length(out.cmle)-M+1):length(out.cmle)])
thetaCMLE <- out.cmle[1:(length(out.cmle)-M)]
rm(value, out.cmle, output)
############################################
# tMLE
load("estimation_output.Rdata")
thetaMLE <- tML.out$model$estimate
rm(tML.out)
############################################
# prepare data for counterfactuals
# create regression matrices
f1 <- as.Formula(~ sqrt(senderecondep) + senderdemocracy + contig + ally -1|#SA
anticipatedsendercosts|#VA
sqrt(targetecondep) + anticipatedtargetcosts + contig + ally|#CB
sqrt(senderecondep) + senderdemocracy + lncaprat | #barWA
targetdemocracy + lncaprat| #barWB
senderdemocracy| #bara
-1) #VB
Xhi <- Xlo <- X
regrhi <- list()
regrlo <- list()
regr <- list()
for(i in 1:7){
regrhi[[i]] <- model.matrix(f1, data=Xhi, rhs=i)
regrlo[[i]] <- model.matrix(f1, data=Xlo, rhs=i)
regr[[i]] <- model.matrix(f1, data=X, rhs=i)
}
names(regrhi) <- c("SA", "VA", "CB", "barWA", "barWB", "bara", "VB")
names(regrlo) <- c("SA", "VA", "CB", "barWA", "barWB", "bara", "VB")
names(regr) <- c("SA", "VA", "CB", "barWA", "barWB", "bara", "VB")
############################################
# prepare data for counterfactuals
# cmle
xThi <- xTlo <- thetaCMLE
xThi[19] <- 0
xTlo[19] <- -6
xThi[20] <- 0
xTlo[20] <- 0
Uhi.cmle <- vec2U.regr(xThi, regr)
Ulo.cmle <- vec2U.regr(xTlo, regr)
U.cmle <- vec2U.regr(thetaCMLE, regr)
Uhi.cmle$sig <- Ulo.cmle$sig <- U.cmle$sig <- rep(1,M)
# tmle
xThi <- xTlo <- thetaMLE
xThi[19] <- 0
xTlo[19] <- -6
xThi[20] <- 0
xTlo[20] <- 0
Uhi.tmle <- vec2U.regr(xThi, regr)
Ulo.tmle <- vec2U.regr(xTlo, regr)
U.tmle <- vec2U.regr(thetaMLE, regr)
Uhi.tmle$sig <- Ulo.tmle$sig <- U.tmle$sig <- rep(1,M)
info <- data.frame(gameID=X$gameID[93],
sender = "USA",
receiver = "CHN",
year = X$tenyear[93])
############################################
# counterfactuals
use <- 93
es <- function(x,k){return(x[k])}
nstep <- 30
out.cmle <- signalEQC(lapply(Ulo.cmle,es,k=use), lapply(Uhi.cmle,es,k=use), length.out=nstep,gridsize=1e4,comp=T)
out.tmle <- signalEQC(lapply(Ulo.tmle,es,k=use), lapply(Uhi.tmle,es,k=use), length.out=nstep,gridsize=1e4,comp=T)
ggdata <- data.frame(x = c(out.cmle[,"i"], out.tmle[,"i"]),
eq = c(out.cmle[,"sols"], out.tmle[,"sols"]),
pc = c(out.cmle[,"sols.pc"], out.tmle[,"sols.pc"]),
pars = c(rep("CMLE", dim(out.cmle)[1]), rep("tMLE", dim(out.tmle)[1])))
vldata <- data.frame(vl = (nstep/6)*c(thetaCMLE[19] + thetaCMLE[20]*X$senderdemocracy[use],
thetaMLE[19] + thetaMLE[20]*X$senderdemocracy[use]) + nstep,
pars = c("CMLE", "tMLE"))
graph <- ggplot(ggdata, aes(x=x,y=pc)) + geom_point(color="navyblue",size=3.5) +
scale_x_continuous(breaks=seq(from=0,to=nstep,length.out=7),
labels = round(seq(from=-6,to=0,by=1), digits=1)) +
theme_bw(18) +
geom_vline(aes(xintercept=vl), data=vldata,color= "orangered1", linetype="dashed", size=1.75) +
facet_grid(cols=vars(pars)) +
xlab( bquote(.(paste(info$sender, "Audience Costs,")) ~ bar(italic(a)))) +
ylab(expression(paste("Prob. of Onset, ", italic(p[C])))) +
ggtitle(paste("Comparative Statics: ", info$sender, "-", info$receiver,", ", info$year,sep=""))
graph
############################################
############################################
######## Estimating Signaling Games ########
########     Economic Sanctions     ########
########        Comp Stat           ########
############################################
############################################
rm(list=ls())
library(pbivnorm)
library(Formula)
library(foreign)
library(ggplot2)
library(doRNG)
library(rootSolve)
library(doParallel)
############################################
# Functions
source("signalingFunctions_main.r")
source("gradientFunctions.r")
############################################
# Data
load("SanctionsDataSet.rdata")
# cow <- read.csv("states2011.csv")
# cow <- unique(cow[,1:3])
# rownames(cow) <- cow$ccode
# Find and remove missing values
missing <- apply(is.na(Xall), 1, max)
Y <- Yall[,missing==0]
X <- Xall[missing==0,]
M <- dim(Y)[2]
rm(Yall, Xall, missing)
############################################
# CMLE
load("CMLE_estimation_output.rdata")
out.cmle <- c(output)
eqCMLE <- plogis(out.cmle[(length(out.cmle)-M+1):length(out.cmle)])
thetaCMLE <- out.cmle[1:(length(out.cmle)-M)]
rm(value, out.cmle, output)
############################################
# tMLE
load("estimation_output.Rdata")
thetaMLE <- tML.out$model$estimate
rm(tML.out)
############################################
# prepare data for counterfactuals
# create regression matrices
f1 <- as.Formula(~ sqrt(senderecondep) + senderdemocracy + contig + ally -1|#SA
anticipatedsendercosts|#VA
sqrt(targetecondep) + anticipatedtargetcosts + contig + ally|#CB
sqrt(senderecondep) + senderdemocracy + lncaprat | #barWA
targetdemocracy + lncaprat| #barWB
senderdemocracy| #bara
-1) #VB
Xhi <- Xlo <- X
regrhi <- list()
regrlo <- list()
regr <- list()
for(i in 1:7){
regrhi[[i]] <- model.matrix(f1, data=Xhi, rhs=i)
regrlo[[i]] <- model.matrix(f1, data=Xlo, rhs=i)
regr[[i]] <- model.matrix(f1, data=X, rhs=i)
}
names(regrhi) <- c("SA", "VA", "CB", "barWA", "barWB", "bara", "VB")
names(regrlo) <- c("SA", "VA", "CB", "barWA", "barWB", "bara", "VB")
names(regr) <- c("SA", "VA", "CB", "barWA", "barWB", "bara", "VB")
############################################
# prepare data for counterfactuals
# cmle
xThi <- xTlo <- thetaCMLE
xThi[19] <- 0
xTlo[19] <- -6
xThi[20] <- 0
xTlo[20] <- 0
Uhi.cmle <- vec2U.regr(xThi, regr)
Ulo.cmle <- vec2U.regr(xTlo, regr)
U.cmle <- vec2U.regr(thetaCMLE, regr)
Uhi.cmle$sig <- Ulo.cmle$sig <- U.cmle$sig <- rep(1,M)
# tmle
xThi <- xTlo <- thetaMLE
xThi[19] <- 0
xTlo[19] <- -6
xThi[20] <- 0
xTlo[20] <- 0
Uhi.tmle <- vec2U.regr(xThi, regr)
Ulo.tmle <- vec2U.regr(xTlo, regr)
U.tmle <- vec2U.regr(thetaMLE, regr)
Uhi.tmle$sig <- Ulo.tmle$sig <- U.tmle$sig <- rep(1,M)
# info <- data.frame(gameID=X$gameID[93],
#                    sender = "USA",
#                    receiver = "CHN",
#                    year = X$tenyear[93])
############################################
# counterfactuals
use <- 93
es <- function(x,k){return(x[k])}
nstep <- 30
out.cmle <- signalEQC(lapply(Ulo.cmle,es,k=use), lapply(Uhi.cmle,es,k=use), length.out=nstep,gridsize=1e4,comp=T)
out.tmle <- signalEQC(lapply(Ulo.tmle,es,k=use), lapply(Uhi.tmle,es,k=use), length.out=nstep,gridsize=1e4,comp=T)
ggdata <- data.frame(x = c(out.cmle[,"i"], out.tmle[,"i"]),
eq = c(out.cmle[,"sols"], out.tmle[,"sols"]),
pc = c(out.cmle[,"sols.pc"], out.tmle[,"sols.pc"]),
pars = c(rep("CMLE", dim(out.cmle)[1]), rep("tMLE", dim(out.tmle)[1])))
vldata <- data.frame(vl = (nstep/6)*c(thetaCMLE[19] + thetaCMLE[20]*X$senderdemocracy[use],
thetaMLE[19] + thetaMLE[20]*X$senderdemocracy[use]) + nstep,
pars = c("CMLE", "tMLE"))
graph <- ggplot(ggdata, aes(x=x,y=pc)) + geom_point(color="navyblue",size=3.5) +
scale_x_continuous(breaks=seq(from=0,to=nstep,length.out=7),
labels = round(seq(from=-6,to=0,by=1), digits=1)) +
theme_bw(18) +
geom_vline(aes(xintercept=vl), data=vldata,color= "orangered1", linetype="dashed", size=1.75) +
facet_grid(cols=vars(pars)) +
xlab( bquote(.(paste(info$sender, "Audience Costs,")) ~ bar(italic(a)))) +
ylab(expression(paste("Prob. of Onset, ", italic(p[C]))))
name <- 'figure6.pdf'
ggsave(name,
plot=graph, height=6.5, width=12.944
)
############################################
############################################
######## Estimating Signaling Games ########
########     Economic Sanctions     ########
########        Comp Stat           ########
############################################
############################################
rm(list=ls())
library(pbivnorm)
library(Formula)
library(foreign)
library(ggplot2)
library(doRNG)
library(rootSolve)
library(doParallel)
############################################
# Functions
source("signalingFunctions_main.r")
source("gradientFunctions.r")
############################################
# Data
load("SanctionsDataSet.rdata")
# cow <- read.csv("states2011.csv")
# cow <- unique(cow[,1:3])
# rownames(cow) <- cow$ccode
# Find and remove missing values
missing <- apply(is.na(Xall), 1, max)
Y <- Yall[,missing==0]
X <- Xall[missing==0,]
M <- dim(Y)[2]
rm(Yall, Xall, missing)
############################################
# CMLE
load("CMLE_estimation_output.rdata")
out.cmle <- c(output)
eqCMLE <- plogis(out.cmle[(length(out.cmle)-M+1):length(out.cmle)])
thetaCMLE <- out.cmle[1:(length(out.cmle)-M)]
rm(value, out.cmle, output)
############################################
# tMLE
load("estimation_output.Rdata")
thetaMLE <- tML.out$model$estimate
rm(tML.out)
############################################
# prepare data for counterfactuals
# create regression matrices
f1 <- as.Formula(~ sqrt(senderecondep) + senderdemocracy + contig + ally -1|#SA
anticipatedsendercosts|#VA
sqrt(targetecondep) + anticipatedtargetcosts + contig + ally|#CB
sqrt(senderecondep) + senderdemocracy + lncaprat | #barWA
targetdemocracy + lncaprat| #barWB
senderdemocracy| #bara
-1) #VB
Xhi <- Xlo <- X
regrhi <- list()
regrlo <- list()
regr <- list()
for(i in 1:7){
regrhi[[i]] <- model.matrix(f1, data=Xhi, rhs=i)
regrlo[[i]] <- model.matrix(f1, data=Xlo, rhs=i)
regr[[i]] <- model.matrix(f1, data=X, rhs=i)
}
names(regrhi) <- c("SA", "VA", "CB", "barWA", "barWB", "bara", "VB")
names(regrlo) <- c("SA", "VA", "CB", "barWA", "barWB", "bara", "VB")
names(regr) <- c("SA", "VA", "CB", "barWA", "barWB", "bara", "VB")
############################################
# prepare data for counterfactuals
# cmle
xThi <- xTlo <- thetaCMLE
xThi[19] <- 0
xTlo[19] <- -6
xThi[20] <- 0
xTlo[20] <- 0
Uhi.cmle <- vec2U.regr(xThi, regr)
Ulo.cmle <- vec2U.regr(xTlo, regr)
U.cmle <- vec2U.regr(thetaCMLE, regr)
Uhi.cmle$sig <- Ulo.cmle$sig <- U.cmle$sig <- rep(1,M)
# tmle
xThi <- xTlo <- thetaMLE
xThi[19] <- 0
xTlo[19] <- -6
xThi[20] <- 0
xTlo[20] <- 0
Uhi.tmle <- vec2U.regr(xThi, regr)
Ulo.tmle <- vec2U.regr(xTlo, regr)
U.tmle <- vec2U.regr(thetaMLE, regr)
Uhi.tmle$sig <- Ulo.tmle$sig <- U.tmle$sig <- rep(1,M)
info <- data.frame(gameID=X$gameID[93],
sender = "USA",
receiver = "CHN",
year = X$tenyear[93])
############################################
# counterfactuals
use <- 93
es <- function(x,k){return(x[k])}
nstep <- 30
out.cmle <- signalEQC(lapply(Ulo.cmle,es,k=use), lapply(Uhi.cmle,es,k=use), length.out=nstep,gridsize=1e4,comp=T)
out.tmle <- signalEQC(lapply(Ulo.tmle,es,k=use), lapply(Uhi.tmle,es,k=use), length.out=nstep,gridsize=1e4,comp=T)
ggdata <- data.frame(x = c(out.cmle[,"i"], out.tmle[,"i"]),
eq = c(out.cmle[,"sols"], out.tmle[,"sols"]),
pc = c(out.cmle[,"sols.pc"], out.tmle[,"sols.pc"]),
pars = c(rep("CMLE", dim(out.cmle)[1]), rep("tMLE", dim(out.tmle)[1])))
vldata <- data.frame(vl = (nstep/6)*c(thetaCMLE[19] + thetaCMLE[20]*X$senderdemocracy[use],
thetaMLE[19] + thetaMLE[20]*X$senderdemocracy[use]) + nstep,
pars = c("CMLE", "tMLE"))
graph <- ggplot(ggdata, aes(x=x,y=pc)) + geom_point(color="navyblue",size=3.5) +
scale_x_continuous(breaks=seq(from=0,to=nstep,length.out=7),
labels = round(seq(from=-6,to=0,by=1), digits=1)) +
theme_bw(18) +
geom_vline(aes(xintercept=vl), data=vldata,color= "orangered1", linetype="dashed", size=1.75) +
facet_grid(cols=vars(pars)) +
xlab( bquote(.(paste(info$sender, "Audience Costs,")) ~ bar(italic(a)))) +
ylab(expression(paste("Prob. of Onset, ", italic(p[C]))))
name <- 'figure6.pdf'
ggsave(name,
plot=graph, height=6.5, width=12.944
)
graph
sessionInfo()
############################################
############################################
######## Estimating Signaling Games ########
########   Monte Carlo Experiment   ########
########     Multiple Equilibria    ########
############################################
############################################
library(ggplot2)
library(data.table)
library(matrixStats)
library(scales)
rm(list=ls())
## Read in the CMLE results
load("CMLE_meq.rdata")
IPOPT <- Results
length(IPOPT)
